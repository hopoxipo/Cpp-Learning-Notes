# 关于constexpr
 这篇文章将主要对其两个方向进行分析：
* constexpr函数
* 字面值常量类

---
*    constexpr函数  
     **constexpr函数是指能用于常量表达式的函数**，它要求函数的返回类型及所有形参的类型都是字面值类型，且函数体中有且只有一条return语句（才怪，可以包含其他语句，只要保证这些语句在运行时不执行任何操作就行，比如说空语句、类型别名以及using声明）。

        ```
        constexpr int new_sz() {return 42; }
        constexpr int foo = new_sz();
        ```
     **允许**constexpr函数的返回值并非一个常量，这是个不错的功能，可以用来做一个简单的筛选条件：
        `` constexpr size_t scale(size_t cnt) {return new_sz() * cnt; }``
        当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则反。
        ```
        int arr[scale(2)];  // √ 返回常量表达式
        int i = 2;
        int a2[scale(i)];   // × 非常量表达式，编译器报错
        ```
        因此，其可以做个简单的筛选条件，不过*不是就报错* 貌似没多大作用，或许可以分离出来做个单独模块，防止大程序的中断，小模块里做一个简单筛选也未免不可。知识有限，今后或许能略懂一二。
        另外，**一般把constexpr函数放在头文件内**。

---
*   字面值常量类  
      >   简单来讲，**数据成员都是字面值类型的聚合类是字面值常量类**（那么什么是聚合类呢？*就是所有成员都是public，没有定义任何构造函数，没有类内初始值，没有基类没有虚函数的类*）
        符合以下特征的也是一个字面值常量类:
      * 数据成员都必须是字面值类型。
      * 类必须至少含有一个constexpr构造函数。
      * 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
      * 类必须使用析构函数的默认定义，负责销毁类的对象。

      >    **这里重点说一下constexpr构造函数**：一方面，构造函数不能包含返回语句；一方面，constexpr函数体内可执行的只能是返回语句。所以constexpr构造函数体一般来说应该是空的，或者说，将其声明成=default或者=delete的形式。
